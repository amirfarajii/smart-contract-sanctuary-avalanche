// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.12;

import "./interface/ITadpole.sol";
import "../lib/solmate/src/auth/Owned.sol";

contract TadpoleMinterBurner is Owned {
    mapping(address => bool) public MinterContract;
    ITadpoleNFT immutable TadpoleNFT;

    error Unauthorited();

    constructor(address _tadpoleAddress) Owned(msg.sender) {
        TadpoleNFT = ITadpoleNFT(_tadpoleAddress);
    }

    function setMinterContract(address _contract, bool _value) external onlyOwner {
        MinterContract[_contract] = _value;
    }

    function burnTadpole(address _tadOwner, uint256 _tokenId) external {
        if (!MinterContract[msg.sender]) {
            revert Unauthorited();
        }
        TadpoleNFT.burn(_tadOwner, _tokenId);
    }

    function mintTadpole(address _receiver, uint256 _seed) external {
        if (!MinterContract[msg.sender]) {
            revert Unauthorited();
        }
        TadpoleNFT.mint(_receiver, _seed);
    }
}

// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.6.4. SEE SOURCE BELOW. !!
pragma solidity ^0.8.4;

interface ITadpoleNFT {
    error InvalidTokenID();
    error Unauthorized();

    event Approval(address indexed owner, address indexed spender, uint256 indexed id);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    event OwnerUpdated(address indexed newOwner);
    event Transfer(address indexed from, address indexed to, uint256 indexed id);

    function _jsonString(uint256 tokenId) external view returns (string memory);

    function approve(address spender, uint256 id) external;

    function balanceOf(address) external view returns (uint256);

    function baseURI() external view returns (string memory);

    function breedingSpot() external view returns (address);

    function burn(address _tadOwner, uint256 _tokenId) external;

    function exchanger() external view returns (address);

    function getApproved(uint256) external view returns (address);

    function isApprovedForAll(address, address) external view returns (bool);

    function mint(address _receiver, uint256 _seed) external;

    function name() external view returns (string memory);

    function nextTokenID() external view returns (uint256);

    function owner() external view returns (address);

    function ownerOf(uint256) external view returns (address);

    function safeTransferFrom(address from, address to, uint256 id) external;

    function safeTransferFrom(address from, address to, uint256 id, bytes memory data) external;

    function setApprovalForAll(address operator, bool approved) external;

    function setBaseURI(string memory _baseURI) external;

    function setBreedingSpot(address _breedingSpot) external;

    function setExchanger(address _exchanger) external;

    function setOwner(address _newOwner) external;

    function supportsInterface(bytes4 interfaceId) external pure returns (bool);

    function symbol() external view returns (string memory);

    function tadpoles(uint256) external view returns (uint128 category, uint64 skin, uint56 hat, uint8 background);

    function tokenURI(uint256 tokenId) external view returns (string memory);

    function transferFrom(address from, address to, uint256 id) external;
}

// THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:

// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

/// @notice Simple single owner authorization mixin.
/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)
abstract contract Owned {
    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/

    event OwnerUpdated(address indexed user, address indexed newOwner);

    /*//////////////////////////////////////////////////////////////
                            OWNERSHIP STORAGE
    //////////////////////////////////////////////////////////////*/

    address public owner;

    modifier onlyOwner() virtual {
        require(msg.sender == owner, "UNAUTHORIZED");

        _;
    }

    /*//////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(address _owner) {
        owner = _owner;

        emit OwnerUpdated(address(0), _owner);
    }

    /*//////////////////////////////////////////////////////////////
                             OWNERSHIP LOGIC
    //////////////////////////////////////////////////////////////*/

    function setOwner(address newOwner) public virtual onlyOwner {
        owner = newOwner;

        emit OwnerUpdated(msg.sender, newOwner);
    }
}